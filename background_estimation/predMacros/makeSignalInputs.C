

#if !defined(__CINT__) || defined(__MAKECINT__)

#include "../predTools/makeJSON.C"
#include "../predTools/makePlots.C"
#include "../predTools/InputsHelper.h"
#include "../predTools/FunctionFitter.C"
#include "../predTools/PDFAdder.h"
#include "AnalysisSupport/Utilities/interface/HistGetter.h"

void makeSignalPDFSystDists(const std::string& name, const std::string& filename,const std::vector<int>& signalMassBins,  const std::string inputFile){
    int nameIDX =  inputFile.find("XXX", 0);
    std::vector<PlotVar> vars;
    std::vector<PlotSel> sels;
    sels.emplace_back(lepCats[LEP_EMU] +"_"+btagCats[BTAG_LMT]+"_"+purCats[PURE_I] +"_"+selCuts1[SEL1_FULL],
            lepCats[LEP_EMU].cut +"&&"+btagCats[BTAG_LMT].cut+"&&"+purCats[PURE_I].cut+"&&"+selCuts1[SEL1_FULL].cut+"&&"+hhRange.cut+"&&"+hbbRange.cut);
    sels.emplace_back("incl","1.0");

    vars.emplace_back("yield",std::string("; yield"),"0.0",1,-1,1.0 );

    for(const auto& sM : signalMassBins){
        const std::string sigName =name+"_m"+ASTypes::int2Str(sM);
        const std::string outFileName=filename+"_"+sigName + "_pdfSyst_distributions.root";
        std::string inputName = inputFile;
        inputName.replace(nameIDX,3,ASTypes::int2Str(sM));
        std::vector<PlotSamp> samps = { {sigName,"1.0"}};

        for(unsigned int i = 0; i < 6; ++i){
            std::string name = sigName+"_s_"+ASTypes::int2Str(i);
            std::string cut = "w_scale["+ASTypes::int2Str(i)+"]";
            samps.emplace_back(name,cut,true);
        }
        for(unsigned int i = 0; i < 100; ++i){
            std::string name = sigName+"_p_"+ASTypes::int2Str(i);
            std::string cut = "w_pdf["+ASTypes::int2Str(i)+"]";
            samps.emplace_back(name,cut,true);
        }
        MakePlots a(inputName,outFileName,samps,sels,vars,"1.0",nomW.cut);
    }
    std::string compiledFile =  filename+"_"+name + "_pdfSyst_distributions.root";
    std::string allFiles = filename+"_"+name+"_m*" + "_pdfSyst_distributions.root";

    gSystem->Exec((std::string("hadd -f ")+ compiledFile + " " + allFiles).c_str());
    gSystem->Exec((std::string("rm ") + allFiles).c_str());
}
void makeSignalNormSystDists(const std::string& name, const std::string& filename,const std::vector<int>& signalMassBins,  const std::string inputFile, const int channel){
    int nameIDX =  inputFile.find("XXX", 0);
    std::vector<PlotVar> vars;
    std::vector<PlotSel> sels;

    if(channel == 0 || channel == 1) {
        for(const auto& l :lepCats) for(const auto& b :btagCats) for(const auto& p :purCats) for(const auto& h :selCuts1){
            if(h != selCuts1[SEL1_FULL]) continue;
            sels.emplace_back(l +"_"+b+"_"+p +"_"+h,
                    l.cut +"&&"+b.cut+"&&"+p.cut+"&&"+h.cut);
        }
    }
    if(channel == 0 || channel == 2) {
        for(const auto& l :dilepCats) for(const auto& b :btagCats) for(const auto& s :selCuts2){
            if(s != selCuts2[SEL2_FULL]) continue;
            sels.emplace_back(l +"_"+b +"_"+s,l.cut +"&&"+b.cut+"&&"+s.cut);
        }
    }

    vars.emplace_back(hhMCS ,std::string(";")+hhMCS.title,hhMCS.cut,nHHMassBins,minHHMass,maxHHMass );

    std::vector<std::pair<std::string,std::string>> sysStrings = {
            {"muIDUp"    ,"w_muIDUp*xsec*trig_N*pu_N*btag_N"     },
//            {"muISOUp"   ,"w_muISOUp*xsec*trig_N*pu_N*btag_N"    },
            {"elRecoUp"  ,"w_elRecoUp*xsec*trig_N*pu_N*btag_N"   },
            {"elIDUp"    ,"w_elIDUp*xsec*trig_N*pu_N*btag_N"     },
//            {"elISOUp"   ,"w_elISOUp*xsec*trig_N*pu_N*btag_N"    },
            {"b_realUp"  ,"w_b_realUp*xsec*trig_N*pu_N*lep_N"    },
            {"b_fakeUp"  ,"w_b_fakeUp*xsec*trig_N*pu_N*lep_N"    },
            {"puUp"      ,"w_puUp*xsec*trig_N*btag_N*lep_N"      },
            {"muIDDown"  ,"w_muIDDown*xsec*trig_N*pu_N*btag_N"   },
//            {"muISODown" ,"w_muISODown*xsec*trig_N*pu_N*btag_N"  },
            {"elRecoDown","w_elRecoDown*xsec*trig_N*pu_N*btag_N" },
            {"elIDDown"  ,"w_elIDDown*xsec*trig_N*pu_N*btag_N"   },
//            {"elISODown" ,"w_elISODown*xsec*trig_N*pu_N*btag_N"  },
            {"b_realDown","w_b_realDown*xsec*trig_N*pu_N*lep_N"  },
            {"b_fakeDown","w_b_fakeDown*xsec*trig_N*pu_N*lep_N"  },
            {"puDown"    ,"w_puDown*xsec*trig_N*btag_N*lep_N"    }
    };

    for(const auto& sM : signalMassBins){
        const std::string sigName =name+"_m"+ASTypes::int2Str(sM);
        const std::string outFileName=filename+"_"+sigName + "_normSyst_distributions.root";
        std::string inputName = inputFile;
        inputName.replace(nameIDX,3,ASTypes::int2Str(sM));
        std::vector<PlotSamp> samps = { {sigName,nomW.cut}};
        for(auto& sS : sysStrings){
            samps.emplace_back(sigName+"_"+sS.first,sS.second);
        }
        MakePlots a(inputName,outFileName,samps,sels,vars,hhRange.cut+"&&"+hbbRange.cut,"1.0");
    }
    std::string compiledFile =  filename+"_"+name + "_normSyst_distributions.root";
    std::string allFiles = filename+"_"+name+"_m*" + "_normSyst_distributions.root";

    gSystem->Exec((std::string("hadd -f ")+ compiledFile + " " + allFiles).c_str());
    gSystem->Exec((std::string("rm ") + allFiles).c_str());
}
void makeSignalShapeSystDists(const std::string& name, const std::string& filename,const std::vector<int>& signalMassBins, const int channel, const std::string inputFile, const std::string systName){
    int nameIDX =  inputFile.find("XXX", 0);
    std::vector<PlotVar> vars;
    std::vector<PlotSel> sels;

    if(channel == 0 || channel == 1) {
        for(const auto& l :lepCats) for(const auto& b :btagCats) for(const auto& p :purCats) for(const auto& h :selCuts1){
            if(h != selCuts1[SEL1_FULL] && h != selCuts1[SEL1_LTMB]) continue;
            sels.emplace_back(l +"_"+b+"_"+p +"_"+h,
                    l.cut +"&&"+b.cut+"&&"+p.cut+"&&"+h.cut);
        }
    }
    if(channel == 0 || channel == 2) {
        for(const auto& l :dilepCats) for(const auto& b :btagCats) for(const auto& s :selCuts2){
            if(s != selCuts2[SEL2_FULL] && s != selCuts2[SEL2_RPhiB]) continue;
            sels.emplace_back(l +"_"+b +"_"+s,l.cut +"&&"+b.cut+"&&"+s.cut);
        }
    }

    vars.emplace_back(hbbMCS,std::string(";")+hbbMCS.title,hbbMCS.cut,nHbbMassBins,minHbbMass,maxHbbMass,hhMCS,std::string(";")+hhMCS.title,hhMCS.cut,nInclHHMassBins,minInclHHMass,maxInclHHMass );

    for(const auto& sM : signalMassBins){
        const std::string sigName =name+"_m"+ASTypes::int2Str(sM);
        const std::string outFileName=filename+"_"+sigName + "_"+systName+"_distributions.root";
        std::string inputName = inputFile;
        inputName.replace(nameIDX,3,ASTypes::int2Str(sM));
        std::vector<PlotSamp> samps = { {sigName,nomW.cut}};
        MakePlots a(inputName,outFileName,samps,sels,vars,hhInclRange.cut+"&&"+hbbRange.cut,"1.0");
    }
    std::string compiledFile =  filename+"_"+name + "_"+systName+"_distributions.root";
    std::string allFiles = filename+"_"+name+"_m*" + "_"+systName+"_distributions.root";

    gSystem->Exec((std::string("hadd -f ")+ compiledFile + " " + allFiles).c_str());
    gSystem->Exec((std::string("rm ") + allFiles).c_str());
}
//--------------------------------------------------------------------------------------------------
void makeSignalFittingDistributions(const std::string& name, const std::string& filename,
        const std::vector<int>& signalMassBins,  const std::string inputFile,
        const std::string& cut="1.0", bool doIncl = true, int channel = 0){
    int nameIDX =  inputFile.find("XXX", 0);
    std::vector<PlotVar> vars;
    std::vector<PlotSel> sels;

    if(channel==0 || channel==1) {
        CatIterator ci;
        while(ci.getBin()) sels.emplace_back(ci.name(),ci.cut());
    }

    if(channel==0 || channel==2) {
        DilepCatIterator ci;
        while(ci.getBin()) sels.emplace_back(ci.name(),ci.cut());
    }

    if(doIncl){
        vars.emplace_back(hbbMCS,std::string(";")+hbbMCS.title,hbbMCS.cut,
                nInclHbbMassBins,minInclHbbMass,maxInclHbbMass,
                hhMCS,std::string(";")+hhMCS.title,hhMCS.cut,inclHHMassBins );
    } else {
        vars.emplace_back(hbbMCS,std::string(";")+hbbMCS.title,hbbMCS.cut,
                nHbbMassBins,minHbbMass,maxHbbMass,
                hhMCS,std::string(";")+hhMCS.title,hhMCS.cut,hhMassBins );
        vars.emplace_back(hbbMCS,std::string(";")+hbbMCS.title,hbbMCS.cut,
                nHbbMassBins,minHbbMass,maxHbbMass);
        vars.emplace_back(hhMCS ,std::string(";")+hhMCS.title,hhMCS.cut,hhMassBins );
    }


    for(const auto& sM : signalMassBins){
        std::vector<PlotSamp> samps = { {name +"_m"+ASTypes::int2Str(sM),"1.0"}};
        std::string outFileName=filename+"_"+name+"_m"+ASTypes::int2Str(sM) +
                (doIncl ? "_inclM_distributions.root" : "_exclM_distributions.root");
        std::string inputName = inputFile;
        inputName.replace(nameIDX,3,ASTypes::int2Str(sM));

        if(gSystem->AccessPathName(inputName.c_str())) continue;
        MakePlots a(inputName,outFileName,samps,sels,vars,cut,nomW.cut);
    }
    std::string compiledFile =  filename+"_"+name +
            (doIncl ? "_inclM_distributions.root" : "_exclM_distributions.root");
    std::string allFiles = filename+"_"+name+"_m*" +
            (doIncl ? "_inclM_distributions.root" : "_exclM_distributions.root");

    gSystem->Exec((std::string("hadd -f ")+ compiledFile + " " + allFiles).c_str());
    gSystem->Exec((std::string("rm ") + allFiles).c_str());
}
//--------------------------------------------------------------------------------------------------
void combineSignalFittingDistributions(const std::string& filename, const std::vector<int>& signalMassBins, bool doIncl, int channel) {
	std::string fileSuffix = (doIncl ? std::string("inclM") : std::string("exclM")) + "_distributions.root";
	std::string outF = filename+"_"+signals[ALLSIGNAL]+"_" + fileSuffix;
	std::vector<std::string> vars = {"hbbMass_hhMass"};
	if(!doIncl) {
		vars.emplace_back("hbbMass");
		vars.emplace_back("hhMass");
	}
	std::vector<std::string> sels;

	if(channel == 0 || channel == 1) {
        CatIterator ci;
        while(ci.getBin()) sels.emplace_back(ci.name());
	}

	if(channel == 0 || channel == 2) {
        DilepCatIterator ci;
        while(ci.getBin()) sels.emplace_back(ci.name());
	}

	auto *rF = TObjectHelper::getFile(filename+"_"+signals[RADION]+"_"+fileSuffix);
	auto *bF = TObjectHelper::getFile(filename+"_"+signals[BLKGRAV]+"_"+fileSuffix);

	HistGetter plotter;
	for(const auto& mass : signalMassBins) for(const auto& sel : sels) for(const auto& var : vars) {
		std::string histS = "m"+std::to_string(mass)+"_"+sel+"_"+var;
		if(ASTypes::strFind(var,"_")) {
			TH2 *h = (TH2*)rF->Get((signals[RADION]+"_"+histS).c_str());
			h = (TH2*)h->Clone((signals[ALLSIGNAL]+"_"+histS).c_str());
			h->Add( (TH2*)bF->Get((signals[BLKGRAV]+"_"+histS).c_str()) , 1);
			plotter.add2D(h);
		} else {
			TH1 *h = (TH1*)rF->Get((signals[RADION]+"_"+histS).c_str());
			h = (TH1*)h->Clone((signals[ALLSIGNAL]+"_"+histS).c_str());
			h->Add( (TH1*)bF->Get((signals[BLKGRAV]+"_"+histS).c_str()) , 1);
			plotter.add1D(h);
		}
	}
	plotter.write(outF);

	rF->Close();
	bF->Close();
	delete rF;
	delete bF;
}
//--------------------------------------------------------------------------------------------------
void makeSignalYields(const std::string& name, const std::string& filename,
        const std::vector<int>& signalMassBins, int channel){
    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_exclM_distributions.root");

    auto mkYields = [&](std::string catName) {
        FunctionParameterPlotter plotter;
        TGraphErrors* yieldGraph = new TGraphErrors;
        int n = 0;
        for(unsigned int iS = 0; iS < signalMassBins.size(); ++iS){
            std::string hName   = name+"_m"+ASTypes::int2Str(signalMassBins[iS])+"_"+catName;
            auto hh_H = TObjectHelper::getObject<TH1>(iF,hName+"_"+hhMCS,false,false);
            if(hh_H ==0) continue;
            double error = 0;
            double integral = hh_H->IntegralAndError(1,hh_H->GetNbinsX(),error);
            yieldGraph->SetPoint(n,signalMassBins[iS],integral);
            yieldGraph->SetPointError(n,0.0,error);
            n++;
        }
        plotter.addFit(yieldGraph,"yield");
        plotter.write(filename+"_"+name+"_"+catName+"_yield.root");
        std::string argsP1 = std::string("-i ")+ filename+"_"+name+"_"+catName+"_yield.root ";
        argsP1 += " -minX 700 -maxX 3600 ";
        argsP1 += " -g yield:laur6 ";
        argsP1 += " -var "+MOD_MS+" ";
        MakeJSON(filename+"_"+name+"_"+catName+"_yield.json",argsP1);
        delete yieldGraph;
    };

    if(channel==0 || channel==1) {
        CatIterator ci;
        while(ci.getBin()) mkYields(ci.name());
    }

    if(channel==0 || channel==2) {
        DilepCatIterator ci;
        while(ci.getBin()) mkYields(ci.name());
    }

    iF->Close();
    delete iF;
}

//--------------------------------------------------------------------------------------------------
std::string vnMJ(const std::string& var){return var+MOD_MJ;};
std::string vnMR(const std::string& var){return var+MOD_MR;};
const std::string fitMJJStd =vnMJ("mean")+":laur4,"+vnMJ("sigma")+":laur4,"
        +vnMJ("alpha")+":laur4,"+vnMJ("alpha2")+":laur4,"+vnMJ("n")+":pol0,"+vnMJ("n2")+":pol0";
const std::string fitMJJExpo =vnMJ("mean")+":laur4,"+vnMJ("sigma")+":laur4,"
        +vnMJ("alpha")+":laur4,"+vnMJ("alpha2")+":pol1," +vnMJ("n")+":pol0,"+vnMJ("n2")+":pol0,"
        +vnMJ("slope")+":laur4,"+vnMJ("fE")+":pol4";
const std::string fitMVV =vnMR("mean")+":pol1," +vnMR("sigma")+":pol2,"
        +vnMR("alpha")+":laur3," +vnMR("alpha2")+":laur3,"+vnMR("n")+":pol0,"+vnMR("n2")+":pol0";
const std::string fitCond =vnMR("maxS")+":pol0,"
        +vnMR("mean_p1")+":pol2,"+vnMR("sigma_p1")+":laur3";
const std::string fitCondMVV =vnMJ("maxS")+":pol0,"
        +vnMJ("mean_p1")+":pol2,"+vnMJ("sigma_p1")+":pol1";
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
void makeSignal1DShapes(const std::string& name, const std::string& filename,
        const std::vector<int>& signalMassBins,   const std::string& catName,
        const std::string& fitName, bool fitMJJ, CJSON* prevJSON, TFile* iF,
        bool doExpo, bool restrictX = true){
    FunctionParameterPlotter plotter;
    std::vector<std::unique_ptr<FunctionFitter>> fitters;
    const std::string modStr = fitMJJ ? MOD_MJ : MOD_MR;

    auto setup1DFit = [&](const TH1* hbbH, double HHMass)->FunctionFitter*{
        auto vN=[&](std::string var)->std::string{return fitMJJ ? vnMJ(var):vnMR(var);};
        fitters.emplace_back(new CBFunctionFitter(hbbH,{},doExpo,modStr,{modStr}));
        FunctionFitter* fitter = fitters.back().get();

        if(fitMJJ){
            fitter->w->var(modStr.c_str())->setRange("fit",minHbbMass,maxHbbMass);
            fitter->w->var(modStr.c_str())->setRange("coef",minHbbMass,maxHbbMass);
        } else {
            fitter->w->var(modStr.c_str())->setRange("fit",minHHMass,maxHHMass);
            fitter->w->var(modStr.c_str())->setRange("coef",minHHMass,maxHHMass);
        }

        if(fitMJJ){
            fitter->setVar(vN("mean")     ,125,90,180);
            fitter->setVar(vN("sigma")       ,10,5,20);
        } else {
            fitter->setVar(vN("mean")  ,HHMass   ,HHMass -200,HHMass+200);
            fitter->setVar(vN("sigma") ,HHMass*0.05,HHMass*0.025,HHMass*0.2);
        }

        fitter->setVar(vN("n")   ,  5  ,1,6);
        fitter->setVar(vN("n2")  ,5,3,6);
        fitter->setConst(vN("n")  ,1);
        fitter->setConst(vN("n2")  ,1);

        if(prevJSON){
            fitter->setVar(vN("alpha")     ,prevJSON->evalFunc(vN("alpha")  ,HHMass) ,0.1,2);
            fitter->setConst(vN("alpha"),1);
            fitter->setVar(vN("alpha2")  ,prevJSON->evalFunc(vN("alpha2")  ,HHMass),0.1,3);
            fitter->setConst(vN("alpha2")  ,1);
        } else {
            fitter->setVar(vN("alpha")     ,0.9 ,0.1,2);
            fitter->setVar(vN("alpha2")  ,1.5,0.1,3);
        }
        if(doExpo){
            fitter->setVar(vN("slope")  ,-1,-10,0);
            fitter->setVar(vN("fE")  ,0.1,0,0.75);
        }


        fitter->fit({RooFit::SumW2Error(1),RooFit::Range("fit"),
            RooFit::SumCoefRange("coef"),RooFit::NumCPU(4)});
        fitter->fit({RooFit::SumW2Error(1),RooFit::Range("fit"),
            RooFit::SumCoefRange("coef"),RooFit::NumCPU(4)});

     return fitter;
    };


    for(unsigned int iS = 0; iS < signalMassBins.size(); ++iS){
        std::string hName   = name+"_m"+ASTypes::int2Str(signalMassBins[iS])+"_"+catName;
        std::string ptName  = std::string("m") + ASTypes::flt2Str(signalMassBins[iS]);

        auto hbb_hh_H = TObjectHelper::getObject<TH2>(iF,hName+"_"+hbbMCS+"_"+hhMCS,false,false);
        if(hbb_hh_H ==0) continue;
        auto hbb_H = fitMJJ
                ? projX(&*hbb_hh_H,hName+"_"+ptName +"_"+hbbMCS)
                : (restrictX
                        ? projY(&*hbb_hh_H,hName+"_"+ptName +"_"+hbbMCS,115,135)
                        : projY(&*hbb_hh_H,hName+"_"+ptName +"_"+hbbMCS)) ;
        plotter.addFit(setup1DFit(&*hbb_H,signalMassBins[iS]),signalMassBins[iS],ptName);
    }
    plotter.write(filename+"_"+name+"_"+catName+"_"+fitName+".root");

}


//--------------------------------------------------------------------------------------------------
void makeSignalMJJShapes1stIt(const std::string& name, const std::string& filename,
        const std::vector<int>& signalMassBins, int channel){
    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_exclM_distributions.root");
    const std::string fitName = "MJJ_fit1stIt";

    auto mkShapes = [&](std::string catName, bool doExpo) {
        makeSignal1DShapes(name,filename,signalMassBins,catName,fitName,true,0,iF,doExpo);

        std::string argsP1 = std::string("-i ")+filename+"_"+name+"_"+catName+"_"+fitName+".root "
                +" -var "+MOD_MS +" ";
        argsP1 += doExpo ? " -minX 700 -maxX 3800 " :" -minX 700 -maxX 3800 ";
        MakeJSON(filename+"_"+name+"_"+catName+"_"+fitName+".json",argsP1+" -g "
                +  ( doExpo  ?  fitMJJExpo : fitMJJStd ));
    };

    // make shapes for each b-tagging category
    if(channel==0 || channel==1) {
        CatIterator ci;
        while(ci.getBin()){
            if(!ci.is(LEP_EMU )) continue;
//            if(!ci.is(PURE_I  )) continue;
            if(!ci.is(SEL1_NONE)) continue;
            bool doExpo = ci.is(BTAG_L);
            mkShapes(ci.name(),doExpo);
        }
    }

    if(channel==0 || channel==2) {
        DilepCatIterator ci;
        while(ci.getBin()){
            if(!ci.is(LEP_INCL )) continue;
            if(!ci.is(SEL2_NONE)) continue;
            bool doExpo = ci.is(BTAG_L);
            mkShapes(ci.name(),doExpo);
        }
    }

}
//--------------------------------------------------------------------------------------------------
void makeSignalMJJShapes2ndIt(const std::string& name, const std::string& filename,
        const std::vector<int>& signalMassBins, int channel){
    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_exclM_distributions.root");
    const std::string fitName = "MJJ_fit";

    auto mkShapes = [&](std::string catName, bool doExpo) {
        CJSON oldJSON(     filename+"_"+name+"_"+catName+"_MJJ_fit1stIt.json");
        oldJSON.fillFunctions(MOD_MS);
        makeSignal1DShapes(name,filename,signalMassBins,catName,fitName,true,&oldJSON,iF,doExpo);

        std::string argsP1 = std::string("-i ")+filename+"_"+name+"_"+catName+"_"+fitName+".root "
                + " -minX 700 -maxX 3800 "+" -var "+MOD_MS +" ";
        CJSON newJSON = getJSON(filename+"_"+name+"_"+catName+"_"+fitName+".json",argsP1
                +" -g "+  ( doExpo  ?  fitMJJExpo : fitMJJStd ));
        newJSON.replaceEntry(vnMJ("alpha"), oldJSON.getP(vnMJ("alpha")) );
        newJSON.replaceEntry(vnMJ("alpha2"), oldJSON.getP(vnMJ("alpha2")) );
        newJSON.write(filename+"_"+name+"_"+catName+"_"+fitName+".json");
    };

    // make shapes for each b-tagging category
    if(channel==0 || channel==1) {
        CatIterator ci;
        while(ci.getBin()){
            if(!ci.is(LEP_EMU )) continue;
//            if(!ci.is(PURE_I  )) continue;
            if(!ci.is(SEL1_NONE)) continue;

            bool doExpo = ci.is(BTAG_L);
            mkShapes(ci.name(),doExpo);
        }
    }

    if(channel==0 || channel==2) {
        DilepCatIterator ci;
        while(ci.getBin()){
            if(!ci.is(LEP_INCL )) continue;
            if(!ci.is(SEL2_NONE)) continue;
            bool doExpo = ci.is(BTAG_L);
            mkShapes(ci.name(),doExpo);
        }
    }

}

void makeSignalMVVShapes1D(const std::string& name, const std::string& filename,
        const std::vector<int>& signalMassBins, int channel, const std::string postfix = ""){
    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_"+postfix +"distributions.root");
    const std::string fitName =  ASTypes::strFind(postfix,"exclM")
        ? std::string("MVV_fit1stIt") : postfix + "MVV_fit1stIt";

    auto mkShapes = [&](std::string catName) {
        makeSignal1DShapes(name,filename,signalMassBins,catName,fitName,false,0,iF,false,true);

        std::string argsP1 = std::string("-i ")+filename+"_"+name+"_"+catName+"_"+fitName+".root "
                +" -var "+MOD_MS +" ";
        argsP1 += " -minX 700 -maxX 3800 ";
        MakeJSON(filename+"_"+name+"_"+catName+"_"+fitName+".json",argsP1+" -g "+ fitMVV);
    };

    if(channel==0 || channel==1) {
        CatIterator ci;
        while(ci.getBin()){
            if(!ci.is(BTAG_LMT )) continue;
            if(!ci.is(SEL1_NONE)) continue;
            mkShapes(ci.name());
        }
    }

    if(channel==0 || channel==2) {
        DilepCatIterator ci;
        while(ci.getBin()){
            if(!ci.is(LEP_INCL )) continue;
            if(!ci.is(BTAG_LMT )) continue;
            if(!ci.is(SEL2_NONE)) continue;
            mkShapes(ci.name());
        }
    }
}

//
//void makeSignalMVVShapes1stIt(const std::string& name, const std::string& filename, const std::vector<int>& signalMassBins){
//    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_exclM_distributions.root");
//    const std::string fitName = "MVV_fit1stIt";
//    for(const auto& l :lepCats) for(const auto& b :btagCats) for(const auto& p :purCats)  for(const auto& h :hadCuts){
//        if(l == lepCats[LEP_EMU] ) continue;
//        if(b != btagCats[BTAG_LMT] ) continue;
//        //        if(p != purCats[PURE_I] ) continue;
//        if(!(h == hadCuts[HAD_LTMB] || h == hadCuts[HAD_FULL])  ) continue;
//        const std::string catName = l +"_"+b+"_"+p +"_"+h;
//        makeSignal1DShapes(name,filename,signalMassBins,catName,fitName,false,0,iF,false,false);
//
//        std::string argsP1 = std::string("-i ")+ filename+"_"+name+"_"+catName+"_"+fitName+".root "+" -var "+MOD_MS +" ";
//        argsP1 += " -minX 700 -maxX 3800 ";
//        MakeJSON(filename+"_"+name+"_"+catName+"_"+fitName+".json",argsP1+" -g "+ fitMVV);
//    }
//}
//void makeSignalMVVShapes2ndIt(const std::string& name, const std::string& filename, const std::vector<int>& signalMassBins){
//    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_exclM_distributions.root");
//    const std::string fitName = "MVV_fit";
//    for(const auto& l :lepCats) for(const auto& b :btagCats) for(const auto& p :purCats)  for(const auto& h :hadCuts){
//        if(l == lepCats[LEP_EMU] ) continue;
//        if(b != btagCats[BTAG_LMT] ) continue;
//        //        if(p != purCats[PURE_I] ) continue;
//        if(!(h == hadCuts[HAD_LTMB] || h == hadCuts[HAD_FULL])  ) continue;
//        const std::string catName = l +"_"+b+"_"+p +"_"+h;
//        CJSON oldJSON(     filename+"_"+name+"_"+catName+"_MVV_fit1stIt.json");
//        oldJSON.fillFunctions(MOD_MS);
//        makeSignal1DShapes(name,filename,signalMassBins,catName,fitName,false,&oldJSON,iF,false,false);
//
//        std::string argsP1 = std::string("-i ")+ filename+"_"+name+"_"+catName+"_"+fitName+".root "+" -var "+MOD_MS +" ";
//        argsP1 +=  " -minX 700 -maxX 3800 ";
//        CJSON newJSON = getJSON(filename+"_"+name+"_"+catName+"_"+fitName+".json",argsP1+" -g "+fitMVV);
//        newJSON.replaceEntry(vnMJ("alpha"), oldJSON.getP(vnMJ("alpha")) );
//        newJSON.replaceEntry(vnMJ("alpha2"), oldJSON.getP(vnMJ("alpha2")) );
//        newJSON.write(filename+"_"+name+"_"+catName+"_"+fitName+".json");
//
//
//    }
//}
//--------------------------------------------------------------------------------------------------
void makeSignal2DShapes(const std::string& name, const std::string& filename,
        const std::vector<int>& signalMassBins, const std::string& catName,
        std::string& fitName, CJSON* mjjJSON,CJSON* mvvJSON, bool fixMVVinTerms,
        bool doExpo, TFile* iF, const bool cond = true){
    FunctionParameterPlotter plotter;
    std::vector<std::unique_ptr<FunctionFitter>> fitters;

    auto setup2DFit = [&](const TH2* hbbH, const double HHMass)->FunctionFitter*{
        auto pnX =[&] (std::string v) ->std::string{return vnMJ(v);};
        auto pnY =[&] (std::string v) ->std::string{return vnMR(v);};
        if(cond)
            fitters.emplace_back(new CBFunctionFitter2D(hbbH,{},doExpo,"",{MOD_MJ,MOD_MR}));
        else
            fitters.emplace_back(new CBFunctionFitter2DNoCond(hbbH,{},doExpo,"",{MOD_MJ,MOD_MR}));
        FunctionFitter* fitter = fitters.back().get();
        fitter->w->var(MOD_MR.c_str())->setRange("coef",minHHMass,maxHHMass);
        fitter->w->var(MOD_MJ.c_str())->setRange("coef",minHbbMass,maxHbbMass);
        fitter->w->var(MOD_MJ.c_str())->setRange("fit",minHbbMass,maxHbbMass);
        fitter->w->var(MOD_MR.c_str())->setRange("fit",
                std::max(HHMass*.75,minHHMass),std::min(HHMass*1.25,maxHHMass));

        if(mjjJSON){
            fitter->  setVar(pnX("mean")  ,mjjJSON->evalFunc(pnX("mean")  ,HHMass),90,180);
            fitter->  setVar(pnX("sigma") ,mjjJSON->evalFunc(pnX("sigma") ,HHMass),5,20);
            fitter->  setVar(pnX("alpha") ,mjjJSON->evalFunc(pnX("alpha") ,HHMass),0.1,3);
            fitter->  setVar(pnX("alpha2"),mjjJSON->evalFunc(pnX("alpha2"),HHMass),0.1,3);
            fitter->  setVar(pnX("n")     ,mjjJSON->evalFunc(pnX("n")     ,HHMass),1,6);
            fitter->  setVar(pnX("n2")    ,mjjJSON->evalFunc(pnX("n2")    ,HHMass),3,6);
            fitter->setConst(pnX("mean")  ,1);
            fitter->setConst(pnX("sigma") ,1);
            fitter->setConst(pnX("alpha") ,1);
            fitter->setConst(pnX("alpha2"),1);
            fitter->setConst(pnX("n")     ,1);
            fitter->setConst(pnX("n2")    ,1);
            if(doExpo){
                fitter->setVar(pnX("slope") ,mjjJSON->evalFunc(pnX("slope") ,HHMass),-10,0);
                fitter->setVar(pnX("fE")    ,mjjJSON->evalFunc(pnX("fE")    ,HHMass),0,0.75);
                fitter->setConst(pnX("slope")     ,1);
                fitter->setConst(pnX("fE")    ,1);
            }
        }else {
            fitter->  setVar(pnX("mean")  ,125,90,180);
            fitter->  setVar(pnX("sigma") ,10,5,20);
            fitter->  setVar(pnX("alpha") ,0.9 ,0.1,2);
            fitter->  setVar(pnX("alpha2"),1.5,0.1,3);
            fitter->  setVar(pnX("n")     ,5  ,1,6);
            fitter->  setVar(pnX("n2")    ,5,3,6);
            fitter->setConst(pnX("n")     ,1);
            fitter->setConst(pnX("n2")   ,1);
            if(doExpo){
                fitter->setVar(pnX("slope"),-1,-10,0);
                fitter->setVar(pnX("fE")   ,0.1,0,0.75);
            }
        }

        fitter->setVar(pnY("mean")  ,HHMass   ,HHMass -200,HHMass+200);
        fitter->setVar(pnY("sigma") ,HHMass*0.05,HHMass*0.025,HHMass*0.2);
        fitter->setVar(pnY("alpha") ,1.5,0.1,3);
        fitter->setVar(pnY("alpha2"),1.5,0.1,3);
        fitter->setVar(pnY("n")     ,5,1,6);
        fitter->setVar(pnY("n2")    ,5,1,6);
        fitter->setConst(pnY("n")     ,1);
        fitter->setConst(pnY("n2")    ,1);
        if(cond){
            fitter->setVar(pnY("maxS")  ,2.5 ,0,5);
            fitter->setVar(pnY("mean_p1")  ,.044,.01,.10);
            fitter->setVar(pnY("sigma_p1") ,0,0,1);
            fitter->setConst(pnY("maxS")  ,1);
        }


        if(mvvJSON){
            fitter->setVar(pnY("alpha") ,mvvJSON->evalFunc(pnY("alpha") ,HHMass),0.1,3);
            fitter->setVar(pnY("alpha2"),mvvJSON->evalFunc(pnY("alpha2"),HHMass),0.1,3);
            fitter->setVar(pnY("mean")  ,
                    mvvJSON->evalFunc(pnY("mean"),HHMass),HHMass -200,HHMass+200);
            fitter->setVar(pnY("sigma") ,
                    mvvJSON->evalFunc(pnY("sigma"),HHMass),HHMass*0.025,HHMass*0.2);
            fitter->setConst(pnY("alpha")     ,1);
            fitter->setConst(pnY("alpha2")    ,1);
            if(fixMVVinTerms){
                if(cond){
                    fitter->setVar(pnY("mean_p1")  ,
                            mvvJSON->evalFunc(pnY("mean_p1") ,HHMass),.01,.10);
                    fitter->setVar(pnY("sigma_p1") ,
                            mvvJSON->evalFunc(pnY("sigma_p1") ,HHMass),0,1);
                    fitter->setConst(pnY("mean_p1")     ,1);
                    fitter->setConst(pnY("sigma_p1")    ,1);
                }
                fitter->setConst(pnY("mean")     ,1);
                fitter->setConst(pnY("sigma")    ,1);
            }
        }

        fitter->fit({RooFit::SumW2Error(1),RooFit::Range("fit"),RooFit::SumCoefRange("coef"),
            RooFit::NumCPU(4)});
        fitter->fit({RooFit::SumW2Error(1),RooFit::Range("fit"),RooFit::SumCoefRange("coef"),
            RooFit::NumCPU(4)});
        std::cout<< "---------------------------END!-------------------------------"<<std::endl;
        return fitter;

    };

    for(unsigned int iS = 0; iS < signalMassBins.size(); ++iS){
        std::string hName   = name+"_m"+ASTypes::int2Str(signalMassBins[iS])+"_"+catName;
        std::string ptName  = std::string("m") + ASTypes::flt2Str(signalMassBins[iS]);
        auto hbb_hh_H = TObjectHelper::getObject<TH2>(iF,hName+"_"+hbbMCS+"_"+hhMCS,false,false);
        if(hbb_hh_H ==0) continue;
        plotter.addFit2D(setup2DFit(&*hbb_hh_H,signalMassBins[iS]),signalMassBins[iS],ptName);
    }
    plotter.write(filename+"_"+name+"_"+catName+"_"+fitName+".root");
}
//
//void makeSignal2DShapesCondMVV(const std::string& name, const std::string& filename, const std::vector<int>& signalMassBins, std::string& catName, std::string& fitName, CJSON* mjjJSON,CJSON* mvvJSON, bool fixCorrTerms, bool doExpo, TFile* iF){
//    FunctionParameterPlotter plotter;
//    std::vector<std::unique_ptr<FunctionFitter>> fitters;
//
//    auto setup2DFit = [&](const TH2* hbbH, const double HHMass){
//        auto pnX =[&] (std::string v) ->std::string{return vnMJ(v);};
//        auto pnY =[&] (std::string v) ->std::string{return vnMR(v);};
//
//        fitters.emplace_back(new CBFunctionFitter2DCondMVV(hbbH,doExpo,"",{MOD_MJ,MOD_MR}));
//        auto fitter = &* fitters.back();
//        fitter->w->var(MOD_MJ.c_str())->setRange("fit",30,210);
//        fitter->w->var(MOD_MR.c_str())->setRange("fit",std::max(HHMass*.75,minHHMass),std::min(HHMass*1.5,maxHHMass));
//        fitter->w->var(MOD_MR.c_str())->setRange("coef",minHHMass,maxHHMass);
//        fitter->w->var(MOD_MJ.c_str())->setRange("coef",30,210);
//
//        if(mvvJSON){
//            fitter->setVar(pnY("mean")  ,mvvJSON->evalFunc(pnY("mean"),HHMass),HHMass -200,HHMass+200);
//            fitter->setVar(pnY("sigma") ,mvvJSON->evalFunc(pnY("sigma"),HHMass),HHMass*0.025,HHMass*0.2);
//            fitter->setVar(pnY("alpha") ,mvvJSON->evalFunc(pnY("alpha") ,HHMass),0.1,3);
//            fitter->setVar(pnY("alpha2"),mvvJSON->evalFunc(pnY("alpha2"),HHMass),0.1,3);
//            fitter->setVar(pnY("n")     ,mvvJSON->evalFunc(pnY("n"),HHMass),1,6);
//            fitter->setVar(pnY("n2")    ,mvvJSON->evalFunc(pnY("n2"),HHMass),1,6);
//            fitter->setConst(pnY("mean")     ,1);
//            fitter->setConst(pnY("sigma")   ,1);
//            fitter->setConst(pnY("alpha")     ,1);
//            fitter->setConst(pnY("alpha2")   ,1);
//        } else {
//            fitter->setVar(pnY("mean")  ,HHMass   ,HHMass -200,HHMass+200);
//            fitter->setVar(pnY("sigma") ,HHMass*0.05,HHMass*0.025,HHMass*0.2);
//            fitter->setVar(pnY("alpha") ,1.5,0.1,3);
//            fitter->setVar(pnY("alpha2"),1.5,0.1,3);
//            fitter->setVar(pnY("n")     ,5,1,6);
//            fitter->setVar(pnY("n2")    ,5,1,6);
//        }
//        fitter->setConst(pnY("n")     ,1);
//        fitter->setConst(pnY("n2")   ,1);
//
//
//        fitter->  setVar(pnX("mean")  ,125,90,180);
//        fitter->  setVar(pnX("sigma") ,10,5,20);
//        fitter->  setVar(pnX("alpha") ,0.9 ,0.1,2);
//        fitter->  setVar(pnX("alpha2"),1.5,0.1,3);
//        fitter->  setVar(pnX("n")     ,5  ,1,6);
//        fitter->  setVar(pnX("n2")    ,5,3,6);
//        fitter->setVar(pnX("maxS")  ,2.5 ,0,5);
//        fitter->setVar(pnX("mean_p1")  ,.044,.01,.10);
//        //        fitter->setVar(pnX("sigma_p1")  ,0,0,1);
//        if(doExpo){
//            fitter->setVar(pnX("slope"),-1,-10,0);
//            fitter->setVar(pnX("fE")   ,0.1,0,0.75);
//        }
//
//        if(mjjJSON){
//            fitter->  setVar(pnX("alpha") ,mjjJSON->evalFunc(pnX("alpha") ,HHMass),0.1,2);
//            fitter->  setVar(pnX("alpha2"),mjjJSON->evalFunc(pnX("alpha2"),HHMass),0.1,3);
//            fitter->  setVar(pnX("n")     ,mjjJSON->evalFunc(pnX("n")     ,HHMass),1,6);
//            fitter->  setVar(pnX("n2")    ,mjjJSON->evalFunc(pnX("n2")    ,HHMass),3,6);
//            fitter->setConst(pnX("alpha")     ,1);
//            fitter->setConst(pnX("alpha2")     ,1);
//            if(doExpo){
//                fitter->setVar(pnX("slope"),mjjJSON->evalFunc(pnX("slope")     ,HHMass),-10,0);
//                fitter->setVar(pnX("fE")   ,mjjJSON->evalFunc(pnX("fE")     ,HHMass),0,0.75);
//                fitter->setConst(pnX("slope")     ,1);
//                fitter->setConst(pnX("fE")     ,1);
//            }
//            if(fixCorrTerms){
//                fitter->  setVar(pnX("mean_p1") ,mjjJSON->evalFunc(pnX("mean_p1") ,HHMass),.01,.10);
//                fitter->  setVar(pnX("sigma_p1") ,mjjJSON->evalFunc(pnX("sigma_p1") ,HHMass),0,1);
//                fitter->  setVar(pnX("maxS"),mjjJSON->evalFunc(pnX("maxS"),HHMass),0,5);
//                fitter->setConst(pnX("mean_p1")     ,1);
//                fitter->setConst(pnX("sigma_p1")     ,1);
//            }
//        }
//        fitter->setConst(pnX("maxS")     ,1);
//        fitter->setConst(pnX("n")     ,1);
//        fitter->setConst(pnX("n2")   ,1);
//
//        fitter->fit({RooFit::SumW2Error(1),RooFit::Range("fit"),RooFit::SumCoefRange("coef"),RooFit::NumCPU(8)});
//        fitter->fit({RooFit::SumW2Error(1),RooFit::Range("fit"),RooFit::SumCoefRange("coef"),RooFit::NumCPU(8)});
//        //        fitter->w->writeToFile((filename +"_"+name+"_"+catName+"_"+ASTypes::flt2Str(HHMass)+"_temp.root").c_str(),true);
//        std::cout<< "---------------------------END!-------------------------------"<<std::endl;
//
//    };
//
//    for(unsigned int iS = 0; iS < signalMassBins.size(); ++iS){
//        std::string hName   = name+"_m"+ASTypes::int2Str(signalMassBins[iS])+"_"+catName;
//        std::string ptName  = std::string("m") + ASTypes::flt2Str(signalMassBins[iS]);
//        auto hbb_hh_H = TObjectHelper::getObject<TH2>(iF,hName+"_"+hbbMCS+"_"+hhMCS,false,false);
//        if(hbb_hh_H ==0) continue;
//        setup2DFit(&*hbb_hh_H,signalMassBins[iS]);
//        plotter.addFit2D(&*fitters.back(),signalMassBins[iS],ptName);
//    }
//    plotter.write(filename+"_"+name+"_"+catName+"_"+fitName+".root");
//}
//
////void makeSignal2DShapesCondMVVFirstIteration(const std::string& name, const std::string& filename){
////    std::string fitName = "2D_fit1stIt";
////    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_exclM_distributions.root");
////    for(const auto& l :lepSels) for(const auto& p :purSels) for(const auto& h :hadSels){
////        if(p !=  purSels[PUR_LMT] ) continue;
////        if(h !=  hadSels[HAD_LTMB] ) continue;
////
////        bool doExpo = p ==  purSels[PUR_L];
////
////        std::string catName = l+"_"+p+"_"+h;
////        std::string mjjcatName = lepSels[LEP_EMU] +"_"+p+"_"+hadSels[HAD_LTMB];
////        std::string mvvcatName = l +"_"+purSels[PUR_LMT]+"_"+hadSels[HAD_LTMB];
////        CJSON mjjJSON(     filename+"_"+name+"_"+mjjcatName+"_MJJ_fit1stIt.json");
////        mjjJSON.fillFunctions(MOD_MS);
////        CJSON mvvJSON(     filename+"_"+name+"_"+mvvcatName+"_MVV_fit.json");
////        mvvJSON.fillFunctions(MOD_MS);
////        makeSignal2DShapesCondMVV(name,filename,catName,fitName,&mjjJSON,&mvvJSON,false,doExpo,iF);
////        std::string argsP1 = std::string("-i ")+ filename+"_"+name+"_"+catName+"_"+fitName+".root "+ " -minX 700 -maxX 3800 -var "+MOD_MS+" ";
////        std::string jsonArgs = argsP1 + " -g " +(doExpo ? fitMJJExpo : fitMJJStd ) + ","+fitMVV+","+fitCondMVV;
////        CJSON newJSON = getJSON(filename+"_"+name+"_"+catName+"_"+fitName+".json",jsonArgs);
////        newJSON.replaceEntries(mvvJSON);
//////        newJSON.replaceEntry(vnMJ("alpha"), mjjJSON.getP(vnMJ("alpha")) );
//////        newJSON.replaceEntry(vnMJ("alpha2"), mjjJSON.getP(vnMJ("alpha2")) );
////        if(doExpo){
////            newJSON.replaceEntry(vnMJ("fE"), mjjJSON.getP(vnMJ("fE")) );
////            newJSON.replaceEntry(vnMJ("slope"), mjjJSON.getP(vnMJ("slope")) );
////        }
////        newJSON.write(filename+"_"+name+"_"+catName+"_"+fitName+".json");
////    }
////}
//
//
////void makeSignal2DShapesFirstIteration(const std::string& name, const std::string& filename){
////    std::string fitName = "2D_fit1stIt";
////    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_exclM_distributions.root");
////    for(const auto& l :lepSels) for(const auto& p :purSels) for(const auto& h :hadSels){
////        if(l == lepSels[LEP_EMU] ) continue;
////        if(p !=  purSels[PUR_LMT] ) continue;
////        if(h !=  hadSels[HAD_LTMB] ) continue;
////
////        bool doExpo = p ==  purSels[PUR_L];
////
////        std::string catName = l+"_"+p+"_"+h;
////        std::string mjjcatName = lepSels[LEP_EMU] +"_"+p+"_"+hadSels[HAD_LTMB];
////        std::string mvvcatName = l +"_"+purSels[PUR_LMT]+"_"+hadSels[HAD_LTMB];
////        CJSON mjjJSON(     filename+"_"+name+"_"+mjjcatName+"_MJJ_fit.json");
////        mjjJSON.fillFunctions(MOD_MS);
////        CJSON mvvJSON(     filename+"_"+name+"_"+mvvcatName+"_MVV_fit1stIt.json");
////        mvvJSON.fillFunctions(MOD_MS);
////        makeSignal2DShapes(name,filename,catName,fitName,&mjjJSON,&mvvJSON,false,doExpo,iF);
////        std::string argsP1 = std::string("-i ")+ filename+"_"+name+"_"+catName+"_"+fitName+".root "+ " -minX 700 -maxX 3800 -var "+MOD_MS+" ";
////        std::string jsonArgs = argsP1 + " -g " +(doExpo ? fitMJJExpo : fitMJJStd ) + ","+fitMVV+","+fitCond;
////        CJSON newJSON = getJSON(filename+"_"+name+"_"+catName+"_"+fitName+".json",jsonArgs);
////        newJSON.replaceEntries(mjjJSON);
////        newJSON.replaceEntry(vnMR("alpha"), mvvJSON.getP(vnMR("alpha")) );
////        newJSON.replaceEntry(vnMR("alpha2"), mvvJSON.getP(vnMR("alpha2")) );
////        newJSON.write(filename+"_"+name+"_"+catName+"_"+fitName+".json");
////    }
////}
//--------------------------------------------------------------------------------------------------
void makeSignal2DShapesSecondIteration(const std::string& name, const std::string& filename,
        const std::vector<int>& signalMassBins, int channel){
    std::string fitName = "2D_fit";
    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_exclM_distributions.root");

    if(channel==0 || channel==1) {
        CatIterator ci;
        while(ci.getBin()){
            if(ci.is(LEP_EMU)) continue;
            if(ci.is(BTAG_LMT )) continue;
            if(ci.is(PURE_I  )) continue;
            if(!ci.is(SEL1_FULL)) continue;
            bool doExpo = ci.is(BTAG_L);

            std::string mjjCatName = lepCats[LEP_EMU]+"_"+btagCats[ci.b]
                    +"_"+purCats[ci.p]+"_"+selCuts1[SEL1_NONE];
            std::string mvvCatName = lepCats[ci.l]+"_"+btagCats[BTAG_LMT]+"_"
                    +purCats[ci.p]+"_"+selCuts1[SEL1_NONE];

            CJSON mjjJSON(     filename+"_"+name+"_"+mjjCatName+"_MJJ_fit.json");
            mjjJSON.fillFunctions(MOD_MS);
            CJSON mvvJSON(     filename+"_"+name+"_"+mvvCatName+"_MVV_fit1stIt.json");
            mvvJSON.fillFunctions(MOD_MS);
            makeSignal2DShapes(name,filename,signalMassBins,ci.name(),fitName,
                    &mjjJSON,&mvvJSON,false,doExpo,iF);

            std::string argsP1 = std::string("-i ")+filename+"_"+name+"_"+ci.name()+"_"+fitName+".root "
                    + " -minX 700 -maxX 3800 -var "+MOD_MS+" ";
            std::string jsonArgs = argsP1
                    +" -g "+ (doExpo ? fitMJJExpo : fitMJJStd ) + ","+fitMVV+","+fitCond;

            CJSON newJSON = getJSON(filename+"_"+name+"_"+ci.name()+"_"+fitName+".json",jsonArgs);
            newJSON.replaceEntries(mjjJSON);
            newJSON.replaceEntry(vnMR("alpha"   ), mvvJSON.getP(vnMR("alpha"   )));
            newJSON.replaceEntry(vnMR("alpha2"  ), mvvJSON.getP(vnMR("alpha2"  )));
            newJSON.write(filename+"_"+name+"_"+ci.name()+"_"+fitName+".json");
        }
    }

    if(channel==0 || channel==2) {
        DilepCatIterator ci;
        while(ci.getBin()){
            if(ci.is(LEP_INCL)) continue;
            if(ci.is(BTAG_LMT )) continue;
            if(!ci.is(SEL2_FULL)) continue;
            bool doExpo = ci.is(BTAG_L);

            std::string mjjCatName = dilepCats[LEP_INCL]+"_"+btagCats[ci.b]
                    +"_"+selCuts2[SEL2_NONE];
            std::string mvvCatName = dilepCats[LEP_INCL]+"_"+btagCats[BTAG_LMT]
                    +"_"+selCuts2[SEL2_NONE];

            CJSON mjjJSON(     filename+"_"+name+"_"+mjjCatName+"_MJJ_fit.json");
            mjjJSON.fillFunctions(MOD_MS);
            CJSON mvvJSON(     filename+"_"+name+"_"+mvvCatName+"_MVV_fit1stIt.json");
            mvvJSON.fillFunctions(MOD_MS);
            makeSignal2DShapes(name,filename,signalMassBins,ci.name(),fitName,
                    &mjjJSON,&mvvJSON,false,doExpo,iF);

            std::string argsP1 = std::string("-i ")+filename+"_"+name+"_"+ci.name()+"_"+fitName+".root "
                    + " -minX 700 -maxX 3800 -var "+MOD_MS+" ";
            std::string jsonArgs = argsP1
                    +" -g "+ (doExpo ? fitMJJExpo : fitMJJStd ) + ","+fitMVV+","+fitCond;

            CJSON newJSON = getJSON(filename+"_"+name+"_"+ci.name()+"_"+fitName+".json",jsonArgs);
            newJSON.replaceEntries(mjjJSON);
            newJSON.replaceEntry(vnMR("alpha"   ), mvvJSON.getP(vnMR("alpha"   )));
            newJSON.replaceEntry(vnMR("alpha2"  ), mvvJSON.getP(vnMR("alpha2"  )));
            newJSON.write(filename+"_"+name+"_"+ci.name()+"_"+fitName+".json");
        }
    }
}

//
//
//void copySignalShapes(const std::string& name, const std::string& filename, const std::vector<int>& signalMassBins, const std::string inputName, bool doCond ){
//    std::string fitName = "2D_fit";
//    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_exclM_distributions.root");
//
//    for(const auto& l :lepCats) for(const auto& b :btagCats) for(const auto& p :purCats)  for(const auto& h :hadCuts){
//        if(l == lepCats[LEP_EMU] ) continue;
//        if( b == btagCats[BTAG_LMT] ) continue;
//        if(p == purCats[PURE_I]) continue;
//        if(h != hadCuts[HAD_FULL] ) continue;
//        bool doExpo = b == btagCats[BTAG_L];
//        const std::string catName = l +"_"+b+"_"+p +"_"+h;
//        const std::string inputJSONName = filename+"_"+inputName+"_"+catName+"_"+fitName+".json";
//        TFile * oF = new TFile((filename+"_"+name+"_"+catName+"_"+fitName+".root").c_str(),"recreate");
//
//        RooWorkspace * w = new RooWorkspace("w");
//        w->factory((MOD_MJ + "["+ASTypes::flt2Str(100)+","+ASTypes::flt2Str(0)+","+ASTypes::flt2Str(1000)+"]").c_str());
//        w->factory((MOD_MR + "["+ASTypes::flt2Str(1000)+","+ASTypes::flt2Str(0)+","+ASTypes::flt2Str(10000)+"]").c_str());
//        w->factory((MOD_MS + "["+ASTypes::flt2Str(2000)+","+ASTypes::flt2Str(0)+","+ASTypes::flt2Str(10000)+"]").c_str());
//        if(doCond){
//            PDFAdder::add2DCB(w,name,"PF",MOD_MJ,MOD_MR,inputJSONName,{},{},{},{},doExpo,MOD_MS);
//        } else {
//            PDFAdder::add2DCBNoCond(w,name,"PF",MOD_MJ,MOD_MR,inputJSONName,{},{},{},{},doExpo,MOD_MS);
//        }
//        for(unsigned int iS = 0; iS < signalMassBins.size(); ++iS){
//            std::string hName   = name+"_m"+ASTypes::int2Str(signalMassBins[iS])+"_"+catName;
//            std::string ptName  = std::string("m") + ASTypes::flt2Str(signalMassBins[iS]);
//            auto hbb_hh_H = TObjectHelper::getObject<TH2>(iF,hName+"_"+hbbMCS+"_"+hhMCS,false,false);
//            if(hbb_hh_H ==0) continue;
//            const std::string outDataName = "data_"+ptName;
//            const std::string outPDFName = "pdf_"+ptName;
//            PDFAdder::addBinnedData(w,&*hbb_hh_H,outDataName,{MOD_MJ,MOD_MR});
//            w->var(MOD_MS.c_str())->setVal(signalMassBins[iS]);
//            auto wrt = [&] (TH1* in){
//                in->GetYaxis()->SetTitle(hhMCS.title.c_str());
//                in->GetXaxis()->SetTitle(hbbMCS.title.c_str());
//                oF->cd();
//                in->Write();
//            };
//            wrt(w->pdf((name+"_PF").c_str())->createHistogram(outPDFName.c_str(), *w->var(MOD_MJ.c_str()),RooFit::YVar(*w->var(MOD_MR.c_str()))));
//            wrt(w->data(outDataName.c_str())->createHistogram(outDataName.c_str(), *w->var(MOD_MJ.c_str()),RooFit::YVar(*w->var(MOD_MR.c_str()))));
//        }
//
//        oF->Close();
//        CJSON inputJSON(inputJSONName );
//        inputJSON.write(filename+"_"+name+"_"+catName+"_"+fitName+".json");
//    }
//    iF->Close();
//}
//
//
//void combine2DShapesNoCond(const std::string& name, const std::string& filename, const std::vector<int>& signalMassBins){
//    std::string fitName = "2D_fit";
//    auto * iF =  TObjectHelper::getFile(filename+"_"+name+"_exclM_distributions.root");
//    for(const auto& l :lepCats) for(const auto& b :btagCats) for(const auto& p :purCats)  for(const auto& h :hadCuts){
//        if(l == lepCats[LEP_EMU] ) continue;
//        if(b == btagCats[BTAG_LMT] ) continue;
//        if(p == purCats[PURE_I]) continue;
//        if(h != hadCuts[HAD_FULL] ) continue;
//        bool doExpo = b == btagCats[BTAG_L];
//
//        const std::string catName = l +"_"+b+"_"+p +"_"+h;
//        std::string mjjCatName = lepCats[LEP_EMU]+"_"+b+"_"+purCats[PURE_I]+"_"+hadCuts[HAD_LTMB];
//        std::string mvvCatName = l+"_"+btagCats[BTAG_LMT]+"_"+p+"_"+hadCuts[HAD_FULL];
//
//        CJSON mjjJSON(     filename+"_"+name+"_"+mjjCatName+"_MJJ_fit.json");
//        mjjJSON.fillFunctions(MOD_MS);
//        CJSON mvvJSON(     filename+"_"+name+"_"+mvvCatName+"_MVV_fit1stIt.json");
//        mvvJSON.fillFunctions(MOD_MS);
//        makeSignal2DShapes(name,filename,signalMassBins,catName,fitName,&mjjJSON,&mvvJSON,false,doExpo,iF,false);
//
//        std::string argsP1 = std::string("-i ")+ filename+"_"+name+"_"+catName+"_"+fitName+".root "+ " -minX 700 -maxX 3800 -var "+MOD_MS+" ";
//        std::string jsonArgs = argsP1 +" -g "+ (doExpo ? fitMJJExpo : fitMJJStd ) + ","+fitMVV;
//
//
//        CJSON newJSON = getJSON(filename+"_"+name+"_"+catName+"_"+fitName+".json",jsonArgs);
//        newJSON.replaceEntries(mjjJSON);
//        newJSON.replaceEntries(mvvJSON);
//        newJSON.write(filename+"_"+name+"_"+catName+"_"+fitName+".json");
//    }
//}
//
//


void go(int step, int sig, int channel, std::string treeDir) {
    const std::string filename = hhFilename;

    if(step == 1 || step == 2) sig = SIGNALS::ALLSIGNAL;

    const std::string baseTreeName = treeDir + "/"+signals[sig].cut+  "_mXXX";

    const std::string signalTrees = baseTreeName +".root";
    const std::string name = signals[sig];

    // need to do for spin-0 and spin-2 independently (but not combined)
    if(step == 0){
        makeSignalFittingDistributions(name,filename,signalMassBins[sig],signalTrees,
                hhInclRange.cut+"&&"+hbbInclRange.cut,true,channel);
        makeSignalFittingDistributions(name,filename,signalMassBins[sig],signalTrees,
                hhRange.cut+"&&"+hbbRange.cut,false,channel);
        if(sig != SIGNALS::ALLSIGNAL)
        	makeSignalYields(name,filename,signalMassBins[sig],channel);
    }

    // does combined radion + grav
    if(step == 1) {
    	combineSignalFittingDistributions(filename,signalMassBins[sig],true,channel);
    	combineSignalFittingDistributions(filename,signalMassBins[sig],false,channel);
    }

    // does combined radion + grav
    if(step == 2){
        // fit mbb shape for each mass point, and interpolate btwn mass points for each CB param
        makeSignalMJJShapes1stIt(name,filename,signalMassBins[sig],channel);

        // do mbb fit again, only for mean and sigma, constrain alpha & alpha2
        makeSignalMJJShapes2ndIt(name,filename,signalMassBins[sig],channel);

        // fit mhh shape for each mass point, interpolate for each CB param
        makeSignalMVVShapes1D(name,filename,signalMassBins[sig],channel,"exclM_");

        // correlate the mhh mean and sigma to the mbb mean and sigma and to make 2D templates,
        // then fit to each search region
        makeSignal2DShapesSecondIteration(name,filename,signalMassBins[sig],channel);

        gSystem->Exec((std::string("mkdir -p temp/").c_str()));
        gSystem->Exec((std::string("cp *")+signals[ALLSIGNAL]+"*fit* temp/").c_str());
        gSystem->Exec((std::string("rm *")+signals[RADION]+"*fit*").c_str());
        gSystem->Exec((std::string("rm *")+signals[BLKGRAV]+"*fit*").c_str());
        gSystem->Exec((std::string("rename 's/")+signals[ALLSIGNAL]+"/"+signals[RADION]+"/' *"+signals[ALLSIGNAL]+"*fit*").c_str());
        gSystem->Exec((std::string("rename 's/")+signals[ALLSIGNAL]+"/"+signals[BLKGRAV]+"/' temp/*").c_str());
        gSystem->Exec((std::string("mv temp/* .")).c_str());
        gSystem->Exec((std::string("rm -r temp/")).c_str());
    }

    if(step == 3){
        makeSignalNormSystDists(name,filename,signalMassBins[sig],signalTrees,channel);

        makeSignalShapeSystDists(name,filename,signalMassBins[sig],channel,signalTrees,"NOMSyst");
        makeSignalShapeSystDists(name,filename,signalMassBins[sig],channel,baseTreeName+"_HEM.root","HEM");

        makeSignalShapeSystDists(name,filename,signalMassBins[sig],channel,baseTreeName+"_METUp.root","METUp");
        makeSignalShapeSystDists(name,filename,signalMassBins[sig],channel,baseTreeName+"_JESUp.root","JESUp");
        makeSignalShapeSystDists(name,filename,signalMassBins[sig],channel,baseTreeName+"_JERUp.root","JERUp");
        makeSignalShapeSystDists(name,filename,signalMassBins[sig],channel,baseTreeName+"_METDown.root","METDown");
        makeSignalShapeSystDists(name,filename,signalMassBins[sig],channel,baseTreeName+"_JESDown.root","JESDown");
        makeSignalShapeSystDists(name,filename,signalMassBins[sig],channel,baseTreeName+"_JERDown.root","JERDown");

        makeSignalMVVShapes1D(name,filename,signalMassBins[sig],channel,"NOMSyst_");
        makeSignalMVVShapes1D(name,filename,signalMassBins[sig],channel,"HEM_");
        makeSignalMVVShapes1D(name,filename,signalMassBins[sig],channel,"METUP_"  );
        makeSignalMVVShapes1D(name,filename,signalMassBins[sig],channel,"JESUp_"  );
        makeSignalMVVShapes1D(name,filename,signalMassBins[sig],channel,"JERUp_"  );
        makeSignalMVVShapes1D(name,filename,signalMassBins[sig],channel,"METDown_");
        makeSignalMVVShapes1D(name,filename,signalMassBins[sig],channel,"JESDown_");
        makeSignalMVVShapes1D(name,filename,signalMassBins[sig],channel,"JERDown_");


        makeSignalPDFSystDists(name,filename,signalMassBins[sig],signalTrees);

    }


}
#endif

void makeSignalInputs(int step = 0, int sigToDo = RADION, int channel = 0, std::string treeDir = "../signalPieces/"){
    go(step,sigToDo,channel,treeDir);
}
